
## 4. 二叉树
> 左子树: 2*i+1; 右子树: 2*i+2; 父子书: (i-1)/2
###  递归序：
每个节点都会走过三次
> 先序遍历：头，左，右(递归序首次出现) ；
> 中序遍历：左，头，右(递归序第二次出现) ；
> 后序遍历：左，右，头(递归序第三次出现)
### 非递归序：
利用栈实现
>1. 先序遍历：头入栈，A：先弹出记为cur，B：打印cur，C: 先右再左
> 2. 中序遍历：左，头，右: 左边界全部入栈，弹出后压其右子树；
> 3. 后序遍历：两个栈，头入栈，A：先弹出记为cur，B: 先左再右，C：放入收集栈  D:打印收集栈

### 1. 树的深度度优先遍历
> 先序遍历
### 2. 树的宽度优先遍历 
>队列 先左后右; 每层遍历结束，进入下一层
> 
 ### 3. 最大宽度 TreeMaxWidth
> m1：hashmap:记录node 与层数
> m2:queue:
> 
> 
### 4. 搜索二叉树
>定义 左 < 中 < 右 
> 中序遍历结果为升序
> 递归： 左搜索树，右搜索树，且 左max< X, 右min> X
> m1 递归 
> m2 中序遍历，将结果放入list。list值是否为升序
> m3 非递归
> m4 树形dp: 判断左树是否bst且获得最大值 < x < 判断右树是否bst且获得最小值
### 5. 完全二叉树
> 宽度优先遍历
> 1.任一节点，有右无左，false
> 2. (1)满足， 第一个左右不全，后面所有节点必须是叶子节点，否则false
### 6. 满二叉树
> m1 求最大深度l，再求节点个数n。 n = 2(l) -1;
### 7. 平衡二叉树
> 左右高度差不高于1
> 递归实现
### 8. 树性DP
> 左树所需的条件，右树所需条件，递归。
> 
 ### 9. node1，node2 最低公共祖先??
> 最先汇聚的点
> m1:HashMap+hashSet node1父链加入set，然后查看node2父链存在第一个set内的节点。
### 10. 在二叉树中找到一个节点的后继节点
> 说的都是中序遍历中。
> m1：遍历存入list，找后一个 O(N)
> m2: x的后继：1. x有右树时，右树的最左节点即为后继。
>             2. x无右树时，向父看是否是父左，如果是，则为x后继

### 11. 二叉树序列化，反序列化
>