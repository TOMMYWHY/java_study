
## 4. 二叉树
> 左子树: 2*i+1; 右子树: 2*i+2; 父子书: (i-1)/2
###  递归序：
每个节点都会走过三次
> 先序遍历：头，左，右(递归序首次出现) ；
> 中序遍历：左，头，右(递归序第二次出现) ；
> 后序遍历：左，右，头(递归序第三次出现)
### 非递归序：
利用栈实现
>1. 先序遍历：头入栈，A：先弹出记为cur，B：打印cur，C: 先右再左
> 2. 中序遍历：左，头，右: 左边界全部入栈，弹出后压其右子树；
> 3. 后序遍历：两个栈，头入栈，A：先弹出记为cur，B: 先左再右，C：放入收集栈  D:打印收集栈

### 1. 树的深度度优先遍历
> 先序遍历
### 2. 树的宽度优先遍历 TreeMaxWidth？？？
>队列 先左后右
> 
 ### 3. 最大宽度？？？
> m1：hashmap
> m2:queue
>
### 4. 搜索二叉树
> 左 >中> 右 
> 中序遍历结果为升序